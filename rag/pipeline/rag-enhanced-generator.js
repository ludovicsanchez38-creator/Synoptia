/**
 * RAG-Enhanced Workflow Generator
 * G√©n√®re des workflows n8n enrichis par le contexte de la documentation
 */

const OpenAI = require('openai');
const WorkflowContextRetriever = require('../retrieval/workflow-context-retriever');
const WorkflowValidator = require('../validation/workflow-validator');
const PlanningAgent = require('./planning-agent');
const SupervisorAgent = require('./supervisor-agent');
const { getNodeSchema } = require('../validation/node-schemas');
const config = require('../config');
const costTracker = require('../../utils/cost-tracker');

class RAGEnhancedGenerator {
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
      timeout: config.openai.timeout
    });

    this.retriever = new WorkflowContextRetriever();
    this.validator = new WorkflowValidator();
    this.planningAgent = new PlanningAgent(this.retriever);
    this.supervisorAgent = new SupervisorAgent(this.retriever);
    this.model = config.openai.generationModel;

    this.stats = {
      generated: 0,
      withRAG: 0,
      avgContextDocs: 0,
      avgGenerationTime: 0,
      validationPassed: 0,
      validationFailed: 0
    };
  }

  /**
   * G√©n√®re un workflow enrichi par RAG
   */
  async generate(userRequest, options = {}) {
    const startTime = Date.now();
    const {
      autoFix = config.validation.autoFix,
      maxRetries = config.validation.maxRetries,
      sessionId = null
    } = options;

    // Initialiser le cost tracking pour cette session
    if (sessionId) {
      costTracker.startSession(sessionId);
    }

    try {
      console.log(`\nü§ñ G√©n√©ration workflow avec RAG pour: "${userRequest}"`);

      // 1. R√©cup√©rer contexte RAG
      const context = await this.retriever.getWorkflowContext(userRequest, {
        includeTemplates: config.generation.includeTemplates,
        includeExamples: config.generation.includeExamples
      });

      // Broadcast du contexte RAG r√©cup√©r√©
      if (global.broadcastSSE) {
        global.broadcastSSE('context_retrieved', {
          documentsCount: context.documents?.length || 0,
          workflowExamplesCount: context.workflowExamplesCount || 0,
          detectedNodes: context.detectedNodes || [],
          documents: context.documents?.slice(0, 10).map(d => ({
            title: d.title,
            score: d.score,
            type: d.type,
            nodeType: d.nodeType,
            workflowInfo: d.workflowInfo
          })) || [],
          timestamp: Date.now()
        });
      }

      if (context.fallback) {
        console.warn('‚ö†Ô∏è RAG fallback, g√©n√©ration sans contexte');
      }

      // 2. NOUVEAU: Cr√©er plan avec Planning Agent
      const plan = await this.planningAgent.createPlan(userRequest, context, sessionId);
      const planValidation = this.planningAgent.validatePlan(plan);

      if (!planValidation.valid) {
        console.error('‚ùå Plan invalide:', planValidation.errors);
        throw new Error(`Plan invalide: ${planValidation.errors.join(', ')}`);
      }

      // D√©terminer la complexit√© du workflow pour ajuster le timeout
      const workflowComplexity = this.determineComplexity(plan, context);
      const adaptiveTimeout = this.planningAgent.getTimeoutForComplexity(workflowComplexity);

      console.log(`  ‚è±Ô∏è  Timeout adapt√©: ${adaptiveTimeout/1000}s (complexit√©: ${workflowComplexity})`);

      if (planValidation.warnings.length > 0) {
        console.warn('‚ö†Ô∏è Warnings du plan:');
        planValidation.warnings.forEach(w => console.warn(`   - ${w}`));
      }

      // 3. Construire prompt enrichi AVEC le plan
      console.log('  üìù Construction du prompt enrichi...');
      const prompt = this.buildEnrichedPrompt(userRequest, context, plan);
      console.log('  ‚úÖ Prompt enrichi construit');

      // 4. G√©n√©rer workflow
      if (global.broadcastSSE) {
        global.broadcastSSE('generation_start', {
          agent: 'El Generator',
          icon: 'ü§ñ',
          message: 'Construction du workflow JSON avec les nodes valid√©s',
          timestamp: Date.now()
        });

        // Montrer les d√©tails du plan
        if (plan && plan.requiredNodes) {
          global.broadcastSSE('generation_progress', {
            agent: 'El Generator',
            icon: 'üîç',
            message: `Analyse de ${plan.requiredNodes.length} nodes du plan (${plan.availableNodes || 0} disponibles)`,
            timestamp: Date.now()
          });
        }

        // Montrer la complexit√©
        global.broadcastSSE('generation_progress', {
          agent: 'El Generator',
          icon: 'üß†',
          message: `Mode de raisonnement profond activ√© (GPT-5) - timeout 10min`,
          timestamp: Date.now()
        });
      }

      let workflow = await this.generateWithGPT(prompt, sessionId, adaptiveTimeout);

      if (global.broadcastSSE) {
        global.broadcastSSE('generation_complete', {
          agent: 'El Generator',
          icon: 'ü§ñ',
          message: 'Workflow g√©n√©r√© avec succ√®s',
          nodesCount: workflow.nodes?.length || 0,
          timestamp: Date.now()
        });
      }

      // 5. NOUVEAU: Supervision par Claude (max 3 tentatives)
      let supervisionResult = await this.supervisorAgent.supervise(
        workflow,
        userRequest,
        context,
        1,
        3,
        sessionId
      );

      // 6. Relance si le superviseur rejette
      let supervisionAttempt = 1;
      while (!supervisionResult.approved && supervisionResult.needsRegeneration && supervisionAttempt < 3) {
        supervisionAttempt++;
        console.log(`\nüîÑ RELANCE ${supervisionAttempt}/3 - R√©g√©n√©ration avec feedback du superviseur...`);

        // Ajouter le feedback du superviseur au contexte
        const feedbackContext = {
          ...context,
          previousErrors: supervisionResult.suggestedFixes || [],
          supervisorFeedback: supervisionResult.feedback,
          inventedNodes: supervisionResult.inventedNodes?.map(n => n.name) || []
        };

        // Re-cr√©er un plan avec le feedback
        const newPlan = await this.planningAgent.createPlan(userRequest, feedbackContext, sessionId);

        // Re-g√©n√©rer avec le nouveau plan
        const newPrompt = this.buildEnrichedPrompt(userRequest, feedbackContext, newPlan);
        workflow = await this.generateWithGPT(newPrompt, sessionId, adaptiveTimeout);

        // Re-superviser
        supervisionResult = await this.supervisorAgent.supervise(
          workflow,
          userRequest,
          context,
          supervisionAttempt + 1,
          3,
          sessionId
        );
      }

      if (!supervisionResult.approved) {
        console.error('‚ùå Workflow rejet√© par le superviseur apr√®s toutes les tentatives');
        if (supervisionResult.finalError) {
          console.error(`   Erreur: ${supervisionResult.finalError}`);
        }
      }

      // 7. Valider (exhaustif)
      let validation = { valid: true, errors: [], warnings: [], suggestions: [] };

      if (config.validation.enabled) {
        validation = await this.validator.validateWithScore(workflow);

        console.log(`  üîç Validation: ${validation.valid ? '‚úÖ' : '‚ùå'}`);
        console.log(`     Erreurs: ${validation.errors.length}, Warnings: ${validation.warnings.length}, Suggestions: ${validation.suggestions.length}`);

        // Stats validation
        if (validation.valid) {
          this.stats.validationPassed++;
        } else {
          this.stats.validationFailed++;
        }

        // Auto-fix si √©chec et retry disponible
        if (!validation.valid && autoFix && maxRetries > 0) {
          console.log(`  üîß Workflow invalide, retry avec corrections...`);
          console.log(`     Top 3 erreurs:`);
          validation.errors.slice(0, 3).forEach((err, i) => {
            console.log(`       ${i + 1}. ${err}`);
          });

          workflow = (await this.generate(userRequest, {
            ...options,
            maxRetries: maxRetries - 1,
            previousErrors: validation.errors.slice(0, 5) // Limiter √† 5 erreurs
          })).workflow;

          // Re-valider apr√®s fix
          validation = await this.validator.validateWithScore(workflow);
        } else if (!validation.valid) {
          console.warn(`  ‚ö†Ô∏è Workflow g√©n√©r√© avec ${validation.errors.length} erreur(s)`);
        }

        // Afficher warnings importants
        if (validation.warnings.length > 0) {
          console.log(`  ‚ö†Ô∏è Warnings importants:`);
          validation.warnings.slice(0, 3).forEach((warn, i) => {
            console.log(`     ${i + 1}. ${warn}`);
          });
        }
      }

      // 5. Stats
      const duration = Date.now() - startTime;
      this.updateStats(context, duration);

      console.log(`  ‚úÖ Workflow g√©n√©r√© en ${(duration / 1000).toFixed(1)}s`);
      console.log(`  üìä Contexte: ${context.documents.length} docs, ${context.detectedNodes.length} nodes d√©tect√©s`);

      // 6. Rapport de co√ªts
      if (sessionId) {
        const costReport = costTracker.generateReport(sessionId);
        if (costReport) {
          console.log(costReport);
        }
      }

      return {
        workflow,
        validation, // Inclure r√©sultats validation
        context: {
          documentsUsed: context.documents.length,
          nodesDetected: context.detectedNodes,
          complexity: context.complexity,
          workflowType: context.analysis?.workflowType
        },
        metadata: {
          generatedAt: Date.now(),
          duration,
          model: this.model,
          usedRAG: !context.fallback,
          validated: config.validation.enabled,
          isValid: validation.valid
        }
      };

    } catch (error) {
      console.error('‚ùå Erreur g√©n√©ration workflow:', error.message);
      throw error;
    }
  }

  /**
   * D√©tecte si un trigger est n√©cessaire et lequel
   */
  detectTriggerNeeds(userRequest) {
    const requestLC = userRequest.toLowerCase();

    // Patterns qui indiquent un besoin de trigger
    const triggerIndicators = [
      { keywords: ['quand', 'lorsque', 'd√®s que', 'si', 'when'], type: 'conditional' },
      { keywords: ['tous les', 'chaque', 'quotidien', 'hebdo', 'mensuel', 'every day', 'daily', 'weekly'], type: 'schedule' },
      { keywords: ['formulaire', 'form', 'soumission'], type: 'form' },
      { keywords: ['webhook', 'api', 'http request', 'requ√™te'], type: 'webhook' },
      { keywords: ['email', 'gmail', 'outlook', 'mail'], type: 'email' },
      { keywords: ['chatbot', 'chat', 'conversation'], type: 'chat' },
      { keywords: ['automatique', 'auto', 'automatic'], type: 'auto' }
    ];

    const detected = {
      needsTrigger: false,
      suggestedTrigger: null,
      reason: ''
    };

    // D√©tecter le type de trigger n√©cessaire
    for (const indicator of triggerIndicators) {
      if (indicator.keywords.some(kw => requestLC.includes(kw))) {
        detected.needsTrigger = true;

        // Sugg√©rer le trigger appropri√©
        switch (indicator.type) {
          case 'schedule':
            detected.suggestedTrigger = 'n8n-nodes-base.cron';
            detected.reason = 'Ex√©cution planifi√©e d√©tect√©e';
            break;
          case 'form':
            detected.suggestedTrigger = 'n8n-nodes-base.formTrigger';
            detected.reason = 'Soumission de formulaire d√©tect√©e';
            break;
          case 'webhook':
            detected.suggestedTrigger = 'n8n-nodes-base.webhook';
            detected.reason = 'Webhook/API d√©tect√©';
            break;
          case 'email':
            if (requestLC.includes('quand') || requestLC.includes('lorsque') || requestLC.includes('nouveau')) {
              detected.suggestedTrigger = 'n8n-nodes-base.emailReadImap';
              detected.reason = 'R√©ception email d√©tect√©e';
            } else {
              detected.suggestedTrigger = 'n8n-nodes-base.cron';
              detected.reason = 'Envoi email planifi√© d√©tect√©';
            }
            break;
          case 'chat':
            detected.suggestedTrigger = 'n8n-nodes-langchain.chatTrigger';
            detected.reason = 'Chatbot d√©tect√©';
            break;
          case 'conditional':
          case 'auto':
            // V√©rifier si c'est un email trigger
            if (requestLC.includes('email') || requestLC.includes('gmail')) {
              detected.suggestedTrigger = 'n8n-nodes-base.emailReadImap';
              detected.reason = '√âv√©nement email d√©tect√©';
            } else {
              detected.suggestedTrigger = 'n8n-nodes-base.webhook';
              detected.reason = '√âv√©nement d√©tect√©';
            }
            break;
        }

        if (detected.suggestedTrigger) {
          break; // Premier match gagne
        }
      }
    }

    return detected;
  }

  /**
   * Construit un prompt enrichi avec contexte RAG ET le plan
   */
  buildEnrichedPrompt(userRequest, context, plan = null) {
    const {previousErrors} = context;

    // D√©tecter besoin de trigger
    const triggerNeeds = this.detectTriggerNeeds(userRequest);

    // Contexte documentaire - ENRICHI pour √©viter les nodes invent√©s
    let docsContext = '';
    if (context.documents && context.documents.length > 0) {
      docsContext = '\n\nüìö DOCUMENTATION N8N PERTINENTE (NODES DISPONIBLES):\n\n';

      // Prendre jusqu'√† 15 documents (augment√© de 5 ‚Üí 15)
      // Et 800 caract√®res par doc (augment√© de 400 ‚Üí 800)
      context.documents.slice(0, 15).forEach((doc, i) => {
        docsContext += `[${i + 1}] ${doc.title || 'Document'}\n`;
        if (doc.nodeType) docsContext += `   üè∑Ô∏è  NodeType: ${doc.nodeType}\n`;
        if (doc.url) docsContext += `   üîó URL: ${doc.url}\n`;

        // Workflow example ?
        if (doc.workflowInfo) {
          docsContext += `   üìä Workflow: ${doc.workflowInfo.complexity} (${doc.workflowInfo.nodeCount} n≈ìuds)\n`;
          docsContext += `   üîß Int√©grations: ${doc.workflowInfo.integrations.slice(0, 5).join(', ')}\n`;
        }

        docsContext += `   ${doc.content.substring(0, 800)}...\n\n`;
      });

      docsContext += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
      docsContext += `‚ö†Ô∏è  IMPORTANT: Ces ${Math.min(15, context.documents.length)} documents ci-dessus contiennent\n`;
      docsContext += `les SEULS nodes que tu peux utiliser. Tout autre node sera consid√©r√© comme INVENT√â.\n`;
      docsContext += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    }

    // Exemples de code
    let examplesContext = '';
    if (context.examples && context.examples.length > 0) {
      examplesContext = '\n\nüí° EXEMPLES DE CODE N8N:\n\n';

      context.examples.forEach((ex, i) => {
        examplesContext += `Exemple ${i + 1} (${ex.source}):\n\`\`\`json\n${ex.code}\n\`\`\`\n\n`;
      });
    }

    // Nodes d√©tect√©s avec sch√©mas
    let nodesHint = '';
    if (context.detectedNodes && context.detectedNodes.length > 0) {
      nodesHint = `\n\nüéØ NODES SUGG√âR√âS: ${context.detectedNodes.join(', ')}`;

      // Ajouter informations de sch√©ma pour les nodes d√©tect√©s
      const nodeSchemasInfo = context.detectedNodes
        .map(nodeName => {
          // Essayer de trouver le sch√©ma
          const possibleTypes = [
            `n8n-nodes-base.${nodeName.toLowerCase()}`,
            `n8n-nodes-base.${nodeName.toLowerCase().replace(/\s+/g, '')}`,
            `n8n-nodes-base.${nodeName.toLowerCase().replace(/\s+trigger/i, 'Trigger')}`
          ];

          for (const type of possibleTypes) {
            const schema = getNodeSchema(type);
            if (schema) {
              return `\n  ‚Ä¢ ${nodeName} (${type}):\n    Required params: ${schema.requiredParams.join(', ') || 'none'}\n    Credentials: ${schema.credentialTypes.join(', ') || 'none'}`;
            }
          }
          return null;
        })
        .filter(Boolean);

      if (nodeSchemasInfo.length > 0) {
        nodesHint += '\n\nüìã PARAM√àTRES REQUIS PAR NODE:' + nodeSchemasInfo.join('');
      }
    }

    // Flow sugg√©r√©
    let flowHint = '';
    if (context.suggestedFlow && context.suggestedFlow.length > 0) {
      flowHint = `\nüìã STRUCTURE SUGG√âR√âE: ${context.suggestedFlow.join(' ‚Üí ')}`;
    }

    // Erreurs pr√©c√©dentes si retry
    let errorsContext = '';
    if (previousErrors && previousErrors.length > 0) {
      errorsContext = '\n\n‚ö†Ô∏è ERREURS √Ä CORRIGER:\n';
      previousErrors.forEach(err => {
        errorsContext += `- ${err}\n`;
      });
    }

    // NOUVEAU: Contexte du plan de l'agent planificateur
    let planContext = '';
    if (plan && plan.requiredNodes) {
      planContext = '\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
      planContext += 'üß† PLAN VALID√â PAR EL PLANIFICATOR - √Ä SUIVRE STRICTEMENT\n';
      planContext += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n';

      planContext += `**Analyse:** ${plan.analysis?.description || 'N/A'}\n`;
      planContext += `**Complexit√©:** ${plan.analysis?.complexity || 'N/A'}\n\n`;

      planContext += `**LISTE EXHAUSTIVE DES NODES AUTORIS√âS:**\n`;
      plan.requiredNodes.forEach((node, i) => {
        const status = node.exists ? '‚úÖ AUTORIS√â' : '‚ùå INTERDIT';
        planContext += `\n  ${i + 1}. ${status}: ${node.name}\n`;
        planContext += `     TYPE √Ä UTILISER: "${node.type}"\n`;
        planContext += `     PURPOSE: ${node.purpose}\n`;
        if (!node.exists) {
          planContext += `     ‚ö†Ô∏è CE NODE N'EXISTE PAS - Voir alternatives ci-dessous\n`;
        }
      });

      if (plan.missingNodes && plan.missingNodes.length > 0) {
        planContext += `\n\n‚õî NODES MANQUANTS - NE PAS UTILISER - VOICI LES ALTERNATIVES:\n`;
        planContext += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
        plan.missingNodes.forEach((missing, i) => {
          planContext += `\n  ${i + 1}. ‚ùå NE PAS UTILISER: ${missing.name}\n`;
          planContext += `     RAISON: ${missing.reason}\n`;
          planContext += `     ‚úÖ UTILISER √Ä LA PLACE: ${missing.alternative}\n`;
          planContext += `     ‚Üí TYPE CORRECT: "n8n-nodes-base.httpRequest"\n`;
        });
        planContext += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
      }

      if (plan.executionFlow && plan.executionFlow.length > 0) {
        planContext += `\n**Flux d'ex√©cution sugg√©r√©:**\n`;
        plan.executionFlow.forEach((step, i) => {
          planContext += `  ${i + 1}. ${step}\n`;
        });
      }

      if (plan.warnings && plan.warnings.length > 0) {
        planContext += `\n**‚ö†Ô∏è Avertissements critiques:**\n`;
        plan.warnings.forEach(w => planContext += `  - ${w}\n`);
      }

      planContext += `\n\nüî¥üî¥üî¥ RAPPEL FINAL - LECTURE OBLIGATOIRE üî¥üî¥üî¥\n`;
      planContext += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
      planContext += `\n‚õî R√àGLE #1 - Z√âRO NODE INVENT√â:\n`;
      planContext += `   CHAQUE node du workflow DOIT √™tre dans la liste "NODES AUTORIS√âS" ci-dessus.\n`;
      planContext += `   Si tu ajoutes UN SEUL node qui n'est pas dans cette liste, le workflow sera REJET√â.\n`;
      planContext += `\n‚õî R√àGLE #2 - RESPECTER LES TYPES EXACTS:\n`;
      planContext += `   Utilise le "TYPE √Ä UTILISER" fourni EXACTEMENT tel quel (copier-coller).\n`;
      planContext += `   Ne pas modifier, ne pas inventer des variantes.\n`;
      planContext += `\n‚õî R√àGLE #3 - ALTERNATIVES OBLIGATOIRES:\n`;
      planContext += `   Si un node a "‚ùå INTERDIT" ‚Üí Utilise l'alternative fournie\n`;
      planContext += `   En cas de doute ‚Üí Utilise "n8n-nodes-base.httpRequest"\n`;
      planContext += `\nüö® CONS√âQUENCE EN CAS DE VIOLATION:\n`;
      planContext += `   El Supervisor d√©tectera IMM√âDIATEMENT le node invent√© et REJETTERA le workflow.\n`;
      planContext += `   Tu devras tout recommencer. Ne perds pas de temps, suis le plan.\n`;
      planContext += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    }

    // Instructions trigger si d√©tect√©
    let triggerInstruction = '';
    if (triggerNeeds.needsTrigger && triggerNeeds.suggestedTrigger) {
      triggerInstruction = `

üö® IMPORTANT - TRIGGER REQUIS:
La demande n√©cessite un TRIGGER pour fonctionner automatiquement.
- Type sugg√©r√©: ${triggerNeeds.suggestedTrigger}
- Raison: ${triggerNeeds.reason}
- Le workflow DOIT commencer par ce trigger node
- Assure-toi de configurer correctement ses param√®tres`;
    }

    // Instructions gestion d'erreurs
    const errorHandlingInstruction = `

‚ö†Ô∏è GESTION D'ERREURS:
- IMPORTANT: Le champ "continueOnFail" doit √™tre dans "parameters.options", PAS au niveau root du node
- Structure correcte: { "parameters": { "options": { "continueOnFail": true } } }
- Cela garantit que le workflow continue m√™me en cas d'erreur partielle`;

    // Prompt syst√®me ULTRA-RENFORC√â avec exemples concrets
    const systemPrompt = `Tu es un expert n8n qui g√©n√®re des workflows JSON parfaitement format√©s.

üéØ OBJECTIF:
Cr√©er un workflow n8n fonctionnel et optimis√© pour la demande utilisateur.

üö® R√àGLES ABSOLUES - AUCUNE EXCEPTION - LECTURE OBLIGATOIRE:

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üî¥ INTERDICTION #1 - NE JAMAIS, JAMAIS INVENTER DE NODES üî¥
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚õî R√àGLE ABSOLUE - Z√âRO TOL√âRANCE:
Tu ne dois JAMAIS, sous AUCUN pr√©texte, cr√©er un node dont le type n'est PAS EXPLICITEMENT dans le PLAN VALID√â par El Planificator ci-dessous.

üö® P√âNALIT√â S√âV√àRE:
Si tu inventes un seul node qui n'est pas dans la liste, le workflow sera IMM√âDIATEMENT REJET√â par El Supervisor, et tu devras tout refaire. C'est une perte de temps et d'argent.

‚ùå EXEMPLES R√âELS D'ERREURS √Ä NE JAMAIS REFAIRE:
- "type": "n8n-nodes-base.moveBinaryData" ‚ùå (INVENT√â - n'existe pas)
- "type": "n8n-nodes-base.openAi" ‚ùå (INVENT√â - n'existe pas)
- "type": "n8n-nodes-base.convertToFile" ‚ùå (existe mais rare, v√©rifie le plan)
- "type": "n8n-nodes-base.googleDrive" ‚ùå (INVENT√â - n'existe pas)
- "type": "n8n-nodes-base.linkedin" ‚ùå (INVENT√â - n'existe pas)
- "type": "n8n-nodes-base.veo" ‚ùå (INVENT√â - n'existe pas)
- "type": "n8n-nodes-base.binaryDataManager" ‚ùå (INVENT√â - n'existe pas)

‚úÖ LA SEULE M√âTHODE AUTORIS√âE - PROCESSUS EN 3 √âTAPES:

√âTAPE 1 - CONSULTER LE PLAN:
  Regarde le PLAN VALID√â PAR EL PLANIFICATOR ci-dessous (section requiredNodes)

√âTAPE 2 - V√âRIFIER L'EXISTENCE:
  Pour chaque node que tu veux utiliser:
  ‚úì Est-il dans la liste "requiredNodes" ?
  ‚úì A-t-il le statut "‚úÖ AUTORIS√â" ?
  ‚úì Le champ "type" est-il fourni ?

√âTAPE 3 - APPLIQUER LA R√àGLE:
  ‚Ä¢ Si le node est "‚úÖ AUTORIS√â" ‚Üí Utilise le TYPE EXACT fourni
  ‚Ä¢ Si le node est "‚ùå INTERDIT" ‚Üí Utilise l'ALTERNATIVE fournie
  ‚Ä¢ Si tu h√©sites ‚Üí Utilise "n8n-nodes-base.httpRequest" (TOUJOURS valide)
  ‚Ä¢ Si pas dans la liste ‚Üí NE L'UTILISE PAS (demande √† El Planificator)

üõ°Ô∏è ALTERNATIVES S√õRES - TOUJOURS VALIDES:
- n8n-nodes-base.httpRequest (pour tout appel API externe)
- n8n-nodes-base.code (pour manipulation de donn√©es)
- n8n-nodes-base.set (pour modifier/ajouter des champs)
- n8n-nodes-base.if (pour conditions)
- n8n-nodes-base.merge (pour combiner des donn√©es)

‚ö†Ô∏è CAS SP√âCIAL - CONVERSION BINAIRE:
Si tu as besoin de convertir base64 ‚Üî binaire:
  ‚ùå NE PAS utiliser: moveBinaryData, convertToFile, binaryDataManager
  ‚úÖ UTILISER: "n8n-nodes-base.code" avec du JavaScript

üîí R√àGLES TECHNIQUES:
5. Retourner UNIQUEMENT le JSON du workflow (format n8n valide)
6. Respecter la structure n8n: {name, nodes, connections, settings}
7. Nommer les nodes de mani√®re descriptive (ex: "Send Welcome Email")
8. Positionner les nodes correctement (position: [x, y])
9. Cr√©er des connexions valides entre nodes
10. Ajouter TOUS les param√®tres REQUIS pour chaque node
11. Les nodes comme Slack, Gmail n√©cessitent "resource" et "operation"
12. Inclure "typeVersion" (g√©n√©ralement 1) pour chaque node
13. Ajouter des notes (field "notes") pour documenter les nodes

‚õî INTERDICTION #2 - NE JAMAIS UTILISER LE CHAMP "authentication":
- ‚ùå "authentication": "oAuth2" (INVALIDE - n8n ne reconna√Æt pas ce champ)
- ‚ùå "authentication": "predefinedCredentialType" (INVALIDE)
- ‚úÖ NE PAS mettre de credentials du tout (l'utilisateur les ajoutera manuellement dans n8n)
- ‚úÖ Ajouter une note: "‚ö†Ô∏è Credentials √† configurer manuellement dans n8n"

üîë FORMAT CREDENTIALS (SI ABSOLUMENT N√âCESSAIRE):
Si un node n√©cessite des credentials (OAuth2, API Key, etc.), NE PAS inclure le champ "credentials" ou "authentication".
√Ä LA PLACE: Ajouter une note explicative dans le champ "notes" du node.

Exemple CORRECT:
{
  "parameters": {
    "url": "https://api.linkedin.com/v2/posts",
    "responseFormat": "json"
  },
  "name": "HTTP Request (LinkedIn)",
  "type": "n8n-nodes-base.httpRequest",
  "typeVersion": 4.2,
  "position": [400, 200],
  "id": "unique-id",
  "notes": "‚ö†Ô∏è Credentials OAuth2 √† configurer manuellement dans n8n pour LinkedIn API"
}

Exemple INVALIDE:
{
  "parameters": {...},
  "authentication": "oAuth2", ‚ùå CE CHAMP N'EXISTE PAS
  ...
}${triggerInstruction}${errorHandlingInstruction}

üìä FORMAT ATTENDU:
\`\`\`json
{
  "name": "Nom du Workflow",
  "nodes": [
    {
      "parameters": {...},
      "name": "Node Name",
      "type": "n8n-nodes-base.nodeType",
      "typeVersion": 1,
      "position": [x, y],
      "id": "uuid"
    }
  ],
  "connections": {
    "Node1": {
      "main": [[{"node": "Node2", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
\`\`\`

${planContext}
${docsContext}
${examplesContext}
${nodesHint}
${flowHint}
${errorsContext}

DEMANDE UTILISATEUR:
"${userRequest}"

‚ö†Ô∏è RAPPEL FINAL:
- Utilise UNIQUEMENT les nodes du PLAN VALID√â
- Si un node manque, utilise HTTP Request + API
- V√©rifie chaque node avant de l'ajouter

G√âN√àRE LE WORKFLOW (JSON UNIQUEMENT, PAS D'EXPLICATION):`;

    return systemPrompt;
  }

  /**
   * G√©n√®re le workflow avec GPT
   */
  async generateWithGPT(prompt, sessionId = null, timeout = null) {
    try {
      if (global.broadcastSSE) {
        global.broadcastSSE('generation_progress', {
          agent: 'El Generator',
          icon: 'ü§ñ',
          message: 'Configuration des param√®tres pour chaque node',
          timestamp: Date.now()
        });
      }

      let response;
      let retryCount = 0;
      const maxRetries = 3;

      // Cr√©er un client OpenAI avec le timeout adapt√©
      const openaiClient = timeout ? new (require('openai'))({
        apiKey: process.env.OPENAI_API_KEY,
        timeout
      }) : this.openai;

      while (retryCount <= maxRetries) {
        try {
          response = await openaiClient.chat.completions.create({
            model: this.model,
            messages: [{
              role: 'system',
              content: prompt
            }],
            // GPT-5 utilise max_completion_tokens au lieu de max_tokens
            max_completion_tokens: 128000, // GPT-5 MAX - workflows ultra-complexes
            response_format: { type: 'json_object' } // Force JSON
          });
          break; // Success
        } catch (error) {
          // D√©tecter rate limit 429
          if (error.status === 429 && retryCount < maxRetries) {
            const waitMatch = error.message.match(/try again in ([\d.]+)s/);
            const waitTime = waitMatch ? Math.ceil(parseFloat(waitMatch[1]) * 1000) : 5000;

            console.warn(`  ‚è≥ Rate limit atteint, retry ${retryCount + 1}/${maxRetries} dans ${waitTime/1000}s...`);

            if (global.broadcastSSE) {
              global.broadcastSSE('generation_progress', {
                agent: 'El Generator',
                icon: '‚è≥',
                message: `Rate limit - Retry dans ${waitTime/1000}s`,
                timestamp: Date.now()
              });
            }

            await new Promise(resolve => setTimeout(resolve, waitTime));
            retryCount++;
          } else {
            throw error;
          }
        }
      }

      // Track API costs
      if (sessionId && response.usage) {
        costTracker.recordCall(
          sessionId,
          'generator',
          this.model,
          response.usage.prompt_tokens,
          response.usage.completion_tokens
        );
      }

      const content = response.choices[0].message.content;

      if (global.broadcastSSE) {
        global.broadcastSSE('generation_progress', {
          agent: 'El Generator',
          icon: 'ü§ñ',
          message: 'Cr√©ation des connexions entre nodes',
          timestamp: Date.now()
        });
      }

      // Parser le JSON
      let workflow = JSON.parse(content);

      // V√©rifier que le workflow est valide
      if (!workflow || typeof workflow !== 'object') {
        throw new Error('Le workflow g√©n√©r√© est invalide ou vide');
      }

      // Ajouter IDs manquants
      if (workflow.nodes) {
        workflow.nodes.forEach(node => {
          if (!node.id) {
            node.id = this.generateId();
          }
        });
      }

      // Post-processing: am√©liorer le workflow
      workflow = this.enhanceWorkflow(workflow);

      return workflow;

    } catch (error) {
      console.error('‚ùå Erreur g√©n√©ration GPT:', error.message);
      throw new Error(`G√©n√©ration √©chou√©e: ${error.message}`);
    }
  }


  /**
   * Am√©liore le workflow g√©n√©r√© avec best practices
   */
  enhanceWorkflow(workflow) {
    if (!workflow || !workflow.nodes) return workflow;

    // Nodes qui n√©cessitent gestion d'erreurs
    const criticalNodeTypes = [
      'gmail', 'slack', 'webhook', 'httprequest', 'postgres', 'mysql', 'mongodb',
      'googlesheets', 'notion', 'airtable', 'stripe', 'twilio', 'sendgrid',
      'hubspot', 'salesforce', 'openai', 'code', 'function'
    ];

    workflow.nodes.forEach(node => {
      // 1. Ajouter continueOnFail sur nodes critiques (DANS parameters.options)
      const nodeTypeLC = node.type.toLowerCase();
      const isCritical = criticalNodeTypes.some(ct => nodeTypeLC.includes(ct));

      if (isCritical) {
        // Initialiser parameters si absent
        if (!node.parameters) {
          node.parameters = {};
        }

        // Initialiser options si absent
        if (!node.parameters.options) {
          node.parameters.options = {};
        }

        // Ajouter continueOnFail dans parameters.options (pas au root!)
        if (!node.parameters.options.continueOnFail) {
          node.parameters.options.continueOnFail = true;
        }
      }

      // 2. Enrichir les notes si manquantes
      if (!node.notes || node.notes.trim() === '') {
        node.notes = this.generateNodeNotes(node);
      }
    });

    return workflow;
  }

  /**
   * G√©n√®re des notes pour un node
   */
  generateNodeNotes(node) {
    const typeLC = node.type.toLowerCase();

    // Notes contextuelles selon le type de node
    if (typeLC.includes('trigger') || typeLC.includes('webhook')) {
      return `üöÄ Point d'entr√©e du workflow - D√©clench√© automatiquement`;
    }
    if (typeLC.includes('gmail') || typeLC.includes('email')) {
      return `üìß Op√©ration email - V√©rifier les credentials`;
    }
    if (typeLC.includes('slack') || typeLC.includes('discord') || typeLC.includes('telegram')) {
      return `üí¨ Notification - N√©cessite configuration du channel/chat`;
    }
    if (typeLC.includes('code') || typeLC.includes('function')) {
      return `üíª Code personnalis√© - V√©rifier les inputs/outputs`;
    }
    if (typeLC.includes('http') || typeLC.includes('webhook')) {
      return `üåê Requ√™te API - V√©rifier l'URL et les headers`;
    }
    if (typeLC.includes('database') || typeLC.includes('postgres') || typeLC.includes('mysql') || typeLC.includes('mongo')) {
      return `üóÑÔ∏è Base de donn√©es - V√©rifier les credentials et la requ√™te`;
    }
    if (typeLC.includes('if') || typeLC.includes('switch')) {
      return `üîÄ Logique conditionnelle - D√©finir les conditions`;
    }
    if (typeLC.includes('openai') || typeLC.includes('langchain')) {
      return `ü§ñ IA - Configurer le mod√®le et le prompt`;
    }

    return `üìù ${node.name}`;
  }

  /**
   * G√©n√®re un ID unique
   */
  generateId() {
    return require('crypto').randomUUID();
  }

  /**
   * Met √† jour les stats
   */
  updateStats(context, duration) {
    this.stats.generated++;

    if (!context.fallback) {
      this.stats.withRAG++;
      const prevAvg = this.stats.avgContextDocs;
      this.stats.avgContextDocs = (prevAvg * (this.stats.withRAG - 1) + context.documents.length) / this.stats.withRAG;
    }

    const prevTimeAvg = this.stats.avgGenerationTime;
    this.stats.avgGenerationTime = (prevTimeAvg * (this.stats.generated - 1) + duration) / this.stats.generated;
  }

  /**
   * R√©cup√®re les statistiques
   */
  getStats() {
    const validationTotal = this.stats.validationPassed + this.stats.validationFailed;

    return {
      ...this.stats,
      ragUsageRate: this.stats.generated > 0
        ? ((this.stats.withRAG / this.stats.generated) * 100).toFixed(1) + '%'
        : '0%',
      validationPassRate: validationTotal > 0
        ? ((this.stats.validationPassed / validationTotal) * 100).toFixed(1) + '%'
        : 'N/A',
      avgGenerationTime: (this.stats.avgGenerationTime / 1000).toFixed(1) + 's',
      avgContextDocs: this.stats.avgContextDocs.toFixed(1),
      validatorStats: this.validator.getStats()
    };
  }

  /**
   * D√©termine la complexit√© du workflow bas√©e sur le plan
   */
  determineComplexity(plan, context) {
    const nodeCount = plan.requiredNodes?.length || 0;
    const missingCount = plan.missingNodes?.length || 0;
    const hasConditions = plan.requiredNodes?.some(n =>
      n.type?.includes('if') || n.type?.includes('switch') || n.type?.includes('merge')
    ) || false;

    // Simple : 2-3 nodes, pas de conditions, pas de nodes manquants
    if (nodeCount <= 3 && !hasConditions && missingCount === 0) {
      return 'simple';
    }

    // Complex : 8+ nodes OU 2+ nodes manquants OU conditions multiples
    if (nodeCount >= 8 || missingCount >= 2 || (hasConditions && nodeCount >= 6)) {
      return 'complex';
    }

    // Medium : tout le reste
    return 'medium';
  }

  /**
   * Ferme connexions
   */
  async close() {
    await this.retriever.close();
  }
}

module.exports = RAGEnhancedGenerator;